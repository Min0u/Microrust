{"message":"unused import: `std::ops::Deref`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\eval.rs","byte_start":4,"byte_end":19,"line_start":1,"line_end":1,"column_start":5,"column_end":20,"is_primary":true,"text":[{"text":"use std::ops::Deref;","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\eval.rs","byte_start":0,"byte_end":20,"line_start":1,"line_end":1,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use std::ops::Deref;","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `std::ops::Deref`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\eval.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::ops::Deref;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `Undefined`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\eval.rs","byte_start":160,"byte_end":169,"line_start":5,"line_end":5,"column_start":47,"column_end":56,"is_primary":true,"text":[{"text":"use crate::error::EvalError::{DivisionByZero, Undefined};","highlight_start":47,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\eval.rs","byte_start":158,"byte_end":169,"line_start":5,"line_end":5,"column_start":45,"column_end":56,"is_primary":true,"text":[{"text":"use crate::error::EvalError::{DivisionByZero, Undefined};","highlight_start":45,"highlight_end":56}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `Undefined`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\eval.rs:5:47\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::error::EvalError::{DivisionByZero, Undefined};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `Any`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":327,"byte_end":330,"line_start":20,"line_end":20,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"use std::any::{Any};","highlight_start":16,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":312,"byte_end":332,"line_start":20,"line_end":20,"column_start":1,"column_end":21,"is_primary":true,"text":[{"text":"use std::any::{Any};","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `Any`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:20:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::any::{Any};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^\u001b[0m\n\n"}
{"message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\parsing\\utils.rs","byte_start":3961,"byte_end":3979,"line_start":102,"line_end":102,"column_start":29,"column_end":47,"is_primary":true,"text":[{"text":"            Rule::ptrnew => Expression::NewPtr,","highlight_start":29,"highlight_end":47}],"label":"expected `Expression`, found enum constructor","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\parsing\\utils.rs","byte_start":3873,"byte_end":3931,"line_start":101,"line_end":101,"column_start":33,"column_end":91,"is_primary":false,"text":[{"text":"            Rule::identifier => Expression::Identifier(Identifier::from(primary.as_str())),","highlight_start":33,"highlight_end":91}],"label":"this and all prior arms are found to be of type `Expression`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\parsing\\utils.rs","byte_start":2778,"byte_end":4388,"line_start":83,"line_end":112,"column_start":32,"column_end":10,"is_primary":false,"text":[{"text":"        .map_primary(|primary| match primary.as_rule() {","highlight_start":32,"highlight_end":57},{"text":"            Rule::integer => Expression::Const(ParsedValue::Integer(primary.as_str().parse::<isize>().unwrap())),","highlight_start":1,"highlight_end":114},{"text":"            Rule::boolean => Expression::Const(ParsedValue::Boolean(match primary.as_str() {","highlight_start":1,"highlight_end":93},{"text":"                \"true\" => true,","highlight_start":1,"highlight_end":32},{"text":"                \"false\" => false,","highlight_start":1,"highlight_end":34},{"text":"                _ => unreachable!()","highlight_start":1,"highlight_end":36},{"text":"            })),","highlight_start":1,"highlight_end":17},{"text":"            Rule::lexpr => Expression::ValueAt(parse_lexpr(primary.into_inner())),","highlight_start":1,"highlight_end":83},{"text":"            Rule::expr => parse_expr(primary.into_inner()),","highlight_start":1,"highlight_end":60},{"text":"            Rule::atom => parse_expr(primary.into_inner()),","highlight_start":1,"highlight_end":60},{"text":"            Rule::conditional_expr => {","highlight_start":1,"highlight_end":40},{"text":"                let mut rules = primary.into_inner();","highlight_start":1,"highlight_end":54},{"text":"                let cond = Box::new(parse_expr(rules.next().unwrap().into_inner()));","highlight_start":1,"highlight_end":85},{"text":"                let cond_true = Box::new(parse_expr(rules.next().unwrap().into_inner()));","highlight_start":1,"highlight_end":90},{"text":"                let cond_false = Box::new(parse_expr(rules.next().unwrap().into_inner()));","highlight_start":1,"highlight_end":91},{"text":"                Expression::Conditional{cond, cond_true, cond_false}","highlight_start":1,"highlight_end":69},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Rule::unit => Expression::Const(ParsedValue::Unit),","highlight_start":1,"highlight_end":64},{"text":"            Rule::identifier => Expression::Identifier(Identifier::from(primary.as_str())),","highlight_start":1,"highlight_end":92},{"text":"            Rule::ptrnew => Expression::NewPtr,","highlight_start":1,"highlight_end":48},{"text":"            Rule::deref => {","highlight_start":1,"highlight_end":29},{"text":"                let expr = Box::new(parse_expr(primary.into_inner()));","highlight_start":1,"highlight_end":71},{"text":"                Expression::Deref(expr)","highlight_start":1,"highlight_end":40},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            Rule::ampersand => {","highlight_start":1,"highlight_end":33},{"text":"                let expr = Box::new(parse_expr(primary.into_inner()));","highlight_start":1,"highlight_end":71},{"text":"                Expression::AmpersAnd(expr)","highlight_start":1,"highlight_end":44},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            rule => unreachable!(\"parse_expr expected atom, found {:?}\", rule),","highlight_start":1,"highlight_end":80},{"text":"        })","highlight_start":1,"highlight_end":10}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\parsing\\expression.rs","byte_start":238,"byte_end":244,"line_start":10,"line_end":10,"column_start":5,"column_end":11,"is_primary":false,"text":[{"text":"    NewPtr(PtrKind, Box<Expression>),","highlight_start":5,"highlight_end":11}],"label":"`NewPtr` defines an enum variant constructor here, which should be called","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"         expected enum `Expression`\nfound enum constructor `fn(PtrKind, std::boxed::Box<Expression>) -> Expression {Expression::NewPtr}`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use parentheses to construct this tuple variant","code":null,"level":"help","spans":[{"file_name":"src\\parsing\\utils.rs","byte_start":3979,"byte_end":3979,"line_start":102,"line_end":102,"column_start":47,"column_end":47,"is_primary":true,"text":[{"text":"            Rule::ptrnew => Expression::NewPtr,","highlight_start":47,"highlight_end":47}],"label":null,"suggested_replacement":"(/* PtrKind */, /* std::boxed::Box<Expression> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `match` arms have incompatible types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\parsing\\utils.rs:102:29\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m83\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        .map_primary(|primary| match primary.as_rule() {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m________________________________-\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m84\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Rule::integer => Expression::Const(ParsedValue::Integer(primary.as_str().parse::<isize>().unwrap())),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m85\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Rule::boolean => Expression::Const(ParsedValue::Boolean(match primary.as_str() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m86\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                \"true\" => true,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Rule::identifier => Expression::Identifier(Identifier::from(primary.as_str())),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----------------------------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mthis and all prior arms are found to be of type `Expression`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Rule::ptrnew => Expression::NewPtr,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Expression`, found enum constructor\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            rule => unreachable!(\"parse_expr expected atom, found {:?}\", rule),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`match` arms have incompatible types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m::: \u001b[0m\u001b[0msrc\\parsing\\expression.rs:10:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    NewPtr(PtrKind, Box<Expression>),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`NewPtr` defines an enum variant constructor here, which should be called\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m:          expected enum `\u001b[0m\u001b[0m\u001b[1mExpression\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m            found enum constructor `\u001b[0m\u001b[0m\u001b[1mfn(PtrKind, std::boxed::Box<Expression>) -> Expression {Expression::NewPtr}\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use parentheses to construct this tuple variant\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m            Rule::ptrnew => Expression::NewPtr\u001b[0m\u001b[0m\u001b[38;5;10m(/* PtrKind */, /* std::boxed::Box<Expression> */)\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no variant or associated item named `update_instr` found for enum `Rule` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\parsing\\utils.rs","byte_start":208,"byte_end":227,"line_start":6,"line_end":6,"column_start":10,"column_end":29,"is_primary":false,"text":[{"text":"#[derive(pest_derive::Parser)]","highlight_start":10,"highlight_end":29}],"label":"variant or associated item `update_instr` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\parsing\\utils.rs","byte_start":208,"byte_end":227,"line_start":6,"line_end":6,"column_start":10,"column_end":29,"is_primary":false,"text":[{"text":"#[derive(pest_derive::Parser)]","highlight_start":10,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(pest_derive::Parser)]","def_site_span":{"file_name":"C:\\Users\\Admin\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\pest_derive-2.7.9\\src\\lib.rs","byte_start":13193,"byte_end":13248,"line_start":323,"line_end":323,"column_start":1,"column_end":56,"is_primary":false,"text":[{"text":"pub fn derive_parser(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\parsing\\utils.rs","byte_start":6204,"byte_end":6216,"line_start":157,"line_end":157,"column_start":15,"column_end":27,"is_primary":true,"text":[{"text":"        Rule::update_instr => {","highlight_start":15,"highlight_end":27}],"label":"variant or associated item not found in `Rule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no variant or associated item named `update_instr` found for enum `Rule` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\parsing\\utils.rs:157:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(pest_derive::Parser)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mvariant or associated item `update_instr` not found for this enum\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m157\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Rule::update_instr => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Rule`\u001b[0m\n\n"}
{"message":"no variant or associated item named `drop_instr` found for enum `Rule` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\parsing\\utils.rs","byte_start":208,"byte_end":227,"line_start":6,"line_end":6,"column_start":10,"column_end":29,"is_primary":false,"text":[{"text":"#[derive(pest_derive::Parser)]","highlight_start":10,"highlight_end":29}],"label":"variant or associated item `drop_instr` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\parsing\\utils.rs","byte_start":208,"byte_end":227,"line_start":6,"line_end":6,"column_start":10,"column_end":29,"is_primary":false,"text":[{"text":"#[derive(pest_derive::Parser)]","highlight_start":10,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(pest_derive::Parser)]","def_site_span":{"file_name":"C:\\Users\\Admin\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\pest_derive-2.7.9\\src\\lib.rs","byte_start":13193,"byte_end":13248,"line_start":323,"line_end":323,"column_start":1,"column_end":56,"is_primary":false,"text":[{"text":"pub fn derive_parser(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\parsing\\utils.rs","byte_start":7532,"byte_end":7542,"line_start":183,"line_end":183,"column_start":15,"column_end":25,"is_primary":true,"text":[{"text":"        Rule::drop_instr => {","highlight_start":15,"highlight_end":25}],"label":"variant or associated item not found in `Rule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src\\parsing\\utils.rs","byte_start":7532,"byte_end":7542,"line_start":183,"line_end":183,"column_start":15,"column_end":25,"is_primary":true,"text":[{"text":"        Rule::drop_instr => {","highlight_start":15,"highlight_end":25}],"label":null,"suggested_replacement":"free_instr","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no variant or associated item named `drop_instr` found for enum `Rule` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\parsing\\utils.rs:183:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(pest_derive::Parser)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mvariant or associated item `drop_instr` not found for this enum\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Rule::drop_instr => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvariant or associated item not found in `Rule`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is a variant with a similar name: `free_instr`\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 3 previous errors; 3 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0308, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0308, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
